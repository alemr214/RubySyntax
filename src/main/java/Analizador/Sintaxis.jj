options {
  IGNORE_CASE = true;
  BUILD_PARSER = true;
  STATIC = false;
}

PARSER_BEGIN(Sintaxis)
package Analizador;
public class Sintaxis {
}
PARSER_END(Sintaxis)

/** Inicio del lexico **/

//Tokens omitidos
SKIP : {
      " "
    | "\t"
    | "\r"
    | "\n"
}

//Tokens de palabras reservadas
TOKEN : {
    < BEGIN: "begin">
    | < END: "end">
    | < CASE: "case">
    | < ELSE: "else">
    | < ELSIF: "elsif">
    | < IF: "if">
    | < UNLESS: "unless">
    | < UNTIL: "until">
    | < WHEN: "when">
    | < WHILE: "while">
    | < FOR: "for">
    | < DO: "do">
    | < NEXT: "next">
    | < BREAK: "break">
    | < REDO: "redo">
    | < RETRY: "retry">
    | < RETURN: "return">
    | < YIELD: "yield">
    | < RESCUE: "rescue">
    | < ENSURE: "ensure">
    | < IN: "in">
    | < TRUE: "true">
    | < FALSE: "false">
    | < NIL: "nil">
    | < TKAND: "and">
    | < TKOR: "or">
    | < TKNOT: "not">
    | < CLASS: "class">
    | < MODULE: "module">
    | < DEF: "def">
    | < SELF: "self">
    | < SUPER: "super">
    | < NEW: "new">
    | < ALIAS: "alias">
    | < DEFINED: "defined">
    | < UNDEF: "undef">
    | < PUBLIC: "public">
    | < PRIVATE: "private">
    | < PROTECTED: "protected">
    | < INCLUDE: "include">
    | < EXTEND: "extend">
    | < REQUIRE: "require">
    | < SET: "Set">
    | < HASH: "Hash">
    | < MATRIX: "Matrix">
    | < THEN: "then">
    | < PUTS: "puts">
    | < PRINT: "print">
    | < GETS: "gets">
}

//Tokens de operadores
TOKEN : {
//OPERADORES ARIMETICOS
    < PLUS: "+" >
    | < MINUS: "-" >
    | < MULTIPLICATION: "*" >
    | < DIVISION: "/" >
    | < MODULUS: "%" >
    | < EXPONENTIATION: "**" >
    //OPERADORES DE COMPARASION
    | < EQUALTO: "==" >
    | < NOTEQUAL: "!=" >
    | < LESSTHAN: "<" >
    | < GREATERTHAN: ">" >
    | < LESSTHANEQUAL: "<=" >
    | < GREATERTHANEQUAL: ">=" >
    | < SPACESHIP: "<=>" >
    | < STRICTEQUAL: "===" >
    //OPERDORES LOGICOS
    | < OPAND: "&&" >
    | < OPOR: "||" >
    | < OPNOT: "!" >
    //OPERADORES DE ASIGNACION
    | < ADDASSIGNMENT: "+=" >
    | < SUBASSIGNMENT: "-=" >
    | < MULASSIGNMENT: "*=" >
    | < DIVASSIGNMENT: "/=" >
    | < MODASSIGNMENT: "%=" >
    | < EXPASSIGNMENT: "**=" >
    //OPERADORES DE BITWISE
    | < BITWISEAND: "&" >
    | < BITWISEOR: "|" >
    | < BITWISEXOR: "^" >
    | < BITWISENOT: "~" >
    | < BITWISELEFTSHIFT: "<<" >
    | < BITWISERIGHTSHIFT: ">>" >
    //OPERADORES DE RANGO
    | < INCLUSIVERANGE: ".." >
    | < EXCLUSIVERANGE: "..." >
    | <EQUAL: "=">
}

//Tokens de simbolos
TOKEN : {
    < LPARENT: "(" >
    | < RPARENT: ")" >
    | < LBRACKET: "[" >
    | < RBRACKET: "]" >
    | < LBRACE: "{" >
    | < RBRACE: "}" >
    | < SEMICOLON: ";" >
    | < COLON: ":" >
    | < COMMA: "," >
    | < DOT: "." >
}

//Tokens de comentarios
TOKEN : {
    < COBEGIN: "=begin" >
    | < COEND: "=end" >
    | < COMMENT: "#" (~["\n"])* >
}


//Tokens de numeros
TOKEN : {
    < INTEGERS: (["0"-"9"])+>
    | < DECIMAL: <INTEGERS> "." <INTEGERS> >
    | < COMPLEX: (<INTEGERS> | <DECIMAL> ) ("i" | "I")>
    | < RATIONAL: <INTEGERS> "/" <INTEGERS>>
}

//Tokens de cadenas de texto
TOKEN : {
     < LETTER: ["a"-"z","A"-"Z"]>
    | < IDENTIFIER: (<LETTER>|"_")(<LETTER>|<INTEGERS>|"_")*>
    | < STRING: "\'"(~["\'"])*"\'" | "\""(~["\""])*"\"">
}
/** Fin Lexico */


void parse() :{}
{
    (statements())*
}

void statements(): {}
{
    <BEGIN> statement() <END>
    | <CLASS> <IDENTIFIER> <END>
    | <DEF> <IDENTIFIER> functionDefinition() <END>
    | statement()
}

void statement(): {}
{
    variableDeclaration()
    | controlStructure()
    | outputStatement()
    | functionCall()
    | expression()
}

void variableDeclaration(): {}
{
    <IDENTIFIER> <EQUAL> (operation() | functionCall())
    [ <SEMICOLON> ]
}

void operation(): {}
{
    (value() | parenthesesOperation()) (operator() (value() | parenthesesOperation()))*
}

void parenthesesOperation(): {}
{
    <LPARENT> operation() <RPARENT>
}

void value(): {}
{
    <IDENTIFIER>
    | <INTEGERS>
    | <DECIMAL>
    | <STRING>
    | <TRUE>
    | <FALSE>
    | <NIL>
}

void operator(): {}
{
    <PLUS>
    | <MINUS>
    | <MULTIPLICATION>
    | <DIVISION>
    | <MODULUS>
    | <EXPONENTIATION>
}

void functionCall(): {}
{
    <IDENTIFIER> <LPARENT> (parameters())? <RPARENT>
    [ <SEMICOLON> ]
}

void parameters(): {}
{
    value() (<COMMA> value())*
}

void outputStatement(): {}
{
    (<PUTS> | <PRINT>) <LPARENT> parameters() <RPARENT>
    [ <SEMICOLON> ]
}

void controlStructure(): {}
{
    ifStatement()
    | forStatement()
    | whileStatement()
    | caseStatement()
}

void ifStatement(): {}
{
    <IF> condition() statement() [elseClause()] <END>
}

void elseClause(): {}
{
    <ELSE> statement()
    | <ELSIF> condition() statement() [elseClause()]
}

void forStatement(): {}
{
    <FOR> <IDENTIFIER> <IN> range() <DO> statement() <END>
}

void whileStatement(): {}
{
    <WHILE> condition() <DO> statement() <END>
}

void caseStatement(): {}
{
    <CASE> value() (<WHEN> value() statement())+ [<ELSE> statement()] <END>
}

void condition(): {}
{
    (value() | parenthesesOperation()) relationalOperator() (value() | parenthesesOperation())
}

void relationalOperator(): {}
{
    <EQUALTO>
    | <NOTEQUAL>
    | <LESSTHAN>
    | <GREATERTHAN>
    | <LESSTHANEQUAL>
    | <GREATERTHANEQUAL>
}

void expression(): {}
{
    <IDENTIFIER> <DOT> <IDENTIFIER> <LPARENT> (parameters())? <RPARENT>
    [ <SEMICOLON> ]
}

void functionDefinition(): {}
{
    <LPARENT> (parameters())? <RPARENT> statement() <END>
}

void range(): {}
{
    value() <INCLUSIVERANGE> value()
    | value() <EXCLUSIVERANGE> value()
}